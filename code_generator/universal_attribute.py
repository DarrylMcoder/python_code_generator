import types
import inspect
from . import config
from .code_writer import CodeWriter
from .code_generator import CodeGenerator

class UniversalAttribute:
    """
    This class is used to delay the generation of the code for a method until it is called.
    """
    def __init__(self, name, owner):
        print(f"LazyAttribute: __init__ called for {name}")
        self.name = name
        self.owner = owner

        # Define all the special methods
        special_methods = [
                "__str__", "__repr__", "__int__", "__float__", "__bool__", "__complex__", "__hash__", "__len__", "__iter__", "__getitem__", "__setitem__", "__delitem__", "__add__", "__sub__", "__mul__", "__truediv__", "__floordiv__", "__mod__", "__pow__", "__lt__", "__le__", "__eq__", "__ne__", "__gt__", "__ge__", "__and__", "__or__", "__xor__", "__invert__", "__lshift__", "__rshift__", "__rlshift__", "__rrshift__", "__contains__", "__missing__", "__enter__", "__exit__", "__next__", "__aenter__", "__aexit__", "__aiter__", "__anext__", "__await__"
                ]

        for method in special_methods:
            setattr(self.__class__, method, types.MethodType(self._make_special_method(method), self))

    def _make_special_method(self, method_name):
        def _special_method(self, *args, **kwargs):
            nonlocal method_name
            print(f"LazyAttribute: _special_method called for {self.name}")
            # Generate the code
            method = CodeGenerator().decide_which_method_sets_attribute(cls=self.owner.__class__, attribute_name=self.name, stack=inspect.stack())
            if method == "None":
                # Implement a new method to set the attribute
                code = CodeGenerator().generate_method_for_attribute(self.owner.__class__, self.name, inspect.stack())
                class_source = CodeWriter().insert_code(cls=self.owner.__class__, code=code)
                imports = CodeGenerator().generate_imports(code)
                class_source = CodeWriter().insert_code(main_source=class_source, code=imports)
                commit_message = CodeGenerator().generate_commit_message(old_code="", new_code=code)
                CodeWriter().commit_changes(self.owner.__class__, class_source, commit_message)
            elif method == "class":
                # Add the attribute to the class source as a class attribute
                code = CodeGenerator().generate_class_attribute(self.owner.__class__, self.name, inspect.stack())
                class_source = CodeWriter().insert_code(cls=self.owner.__class__, code=code)
                imports = CodeGenerator().generate_imports(code)
                class_source = CodeWriter().insert_code(main_source=class_source, code=imports)
                commit_message = CodeGenerator().generate_commit_message(old_code="", new_code=code)
                CodeWriter().commit_changes(self.owner.__class__, class_source, commit_message)
            else:
                # Modify an existing method to set the attribute
                existing_method_source = inspect.getsource(self.owner.__class__.__dict__[method])
                code = CodeGenerator().modify_method_for_attribute(self.owner.__class__, self.name, inspect.stack(), method)
                class_source = CodeWriter().replace_code(cls=self.owner.__class__, old_code=existing_method_source, new_code=code)
                imports = CodeGenerator().generate_imports(code)
                class_source = CodeWriter().insert_code(main_source=class_source, code=imports)
                commit_message = CodeGenerator().generate_commit_message(old_code=existing_method_source, new_code=code)
                CodeWriter().commit_changes(self.owner.__class__, class_source, commit_message)

            if config.after_generation == "continue":
                return CodeGenerator().generate_return_value(code, self.name, method_name, args, kwargs)
            elif config.after_generation == "raise":
                raise AttributeError( f"Attribute {self.name} did not exist on class {self.owner.__class__.__name__}.  It has been generated by the code generator and written to file {inspect.getsourcefile(self.owner.__class__)}.  Please validate the generated code and try again.")

        return _special_method

    def __call__(self, *args, **kwargs):
        print("LazyAttribute: __call__ called")
        # Generate the method
        code = CodeGenerator().generate_method(self.owner.__class__, self.name, args, kwargs, inspect.stack())
        class_source = CodeWriter().insert_code(cls=self.owner.__class__, code=code)
        imports = CodeGenerator().generate_imports(code)
        class_source = CodeWriter().insert_code(main_source=class_source, code=imports)
        commit_message = CodeGenerator().generate_commit_message(old_code="", new_code=code)
        CodeWriter().commit_changes(self.owner.__class__, class_source, commit_message)
        if config.after_generation == "continue":
            return CodeGenerator().generate_return_value(code, self.name, "__call__", args, kwargs)
        elif config.after_generation == "raise":
            raise AttributeError( f"Attribute {self.name} did not exist on class {self.owner.__class__.__name__}.  It has been generated by the code generator and committed to branch {config.git_branch}.  Please validate the generated code and try again.")

