import inspect
import subprocess
from .exceptions import CodeGenerationException

class CodeGenerator:
    def generate_method(self, cls, method_name, args, kwargs, frozen_stack):
        code_context = self.get_default_code_context(cls, method_name, frozen_stack)

        prompt = f"Implement the method {cls.__name__}.{method_name} in the class {cls.__name__} with the arguments {args} and the keyword arguments {kwargs}.\n"
        prompt += f"This method was called on an instance of the class {cls.__name__} but it was not defined in the class.\n"
        prompt += "The method was called with the arguments {args} and the keyword arguments {kwargs}.\n"
        prompt += "Do not generate the class definition, only the method implementation.\n"
        prompt += "Your job is to define the method.\n"

        code = self.generate_code(prompt, code_context)
        return code

    def generate_commit_message(self, old_code, new_code):
        if old_code == "":
            prompt = f"The following new code was generated by the code generator: {new_code}\n"
        else:
            prompt = f"The following new code was generated by the code generator: {new_code}\n"
            prompt += f"The following old code was replaced by the new code: {old_code}\n"
        prompt += "Return a commit message for the changes.\n"
        commit_message = self.generate_info(prompt)
        return commit_message

    def generate_info(self, prompt, code_context=""):
        prompt = f"{code_context}\n\n{prompt}"
        prompt += "- Based on the code above, and the instructions, generate a valid response.\n"
        prompt += "- Do not generate any additional text aside from the response that is requested.\n"

        info = self.prompt_ai(prompt)
        return info

    def generate_code(self, prompt, code_context=""):
        prompt = f"{code_context}\n\n{prompt}"
        prompt += "- Generate Python code as described.\n"
        prompt += "- Document the code clearly and concisely with comments to explain what the code does.\n"
        prompt += "- If it is a function, add a docstring to the function.\n"
        prompt += "- Do not generate any additional code beside the code that is described.\n"
        prompt += "- Generate only Python code. Do not generate any explaining text aside from code comments.\n"
        prompt += "- Do not generate any import statements, they will be added later.\n"
        prompt += "- Do not include the text ```python.\n"

        code = self.prompt_ai(prompt)
        # Add AI watermark
        return f"### AI generated code ###\n{code}"

    def generate_imports(self, code):
        prompt = f"The following code was generated by the code generator: {code}\n"
        prompt += "- Generate the Python import statements that are required for the code.\n"
        prompt += "- Do not generate any additional code beside the import statements.\n"
        prompt += "- Generate only Python import statements. Do not generate any explaining text aside from import statements.\n"
        prompt += "- If no import statements are required, return 'None'.\n"
        prompt += "- Do not include any other text beside the import statements or the text 'None'.\n"
        prompt += "- Do not include the text ```python.\n"

        imports = self.prompt_ai(prompt)
        if imports == "None":
            imports = ""
        return imports

    def decide_which_method_sets_attribute(self, cls, attribute_name, code_context):
        prompt = f"The attribute {cls.__name__}.{attribute_name} was accessed on an instance of the class {cls.__name__} but it was not defined in the class.\n"
        prompt += "Your job is to determine if it is a class attribute or an instance attribute.\n"
        prompt += "Return the name of the method that should be modified to set the attribute.\n"
        prompt += "If there is no existing method that can be sensibly modified to set the attribute, return 'None'.\n"
        prompt += "If the attribute should be defined as a class attribute, return 'class'. In this case, the attribute will be added to the class source as a class attribute.\n"
        prompt += "If there is a method that can be sensibly modified to set the attribute, return the name of the method.\n"
        prompt += "Return only 'class' or 'None' or the name of the method that should be modified to set the attribute.\n"

        method = self.generate_info(prompt, code_context)

        return method

    def get_default_code_context(self, cls, method_name, frozen_stack):
        parent_class_sources = self.get_parent_class_sources(cls, method_name)
        sibling_class_sources = self.get_sibling_class_sources(cls, method_name)
        caller_source = self.get_calling_code(stack=frozen_stack, stack_depth=1)
        stack_trace = self.get_stack_trace(frozen_stack, start_depth=1)
        self_source = self.get_class_source(cls, method_name, full=True)
        
        code_context = f"Parent classes of {cls.__name__}:\n {parent_class_sources}\n"
        code_context += f"Sibling classes of {cls.__name__}:\n {sibling_class_sources}\n"
        code_context += f"Code of around the call:\n {caller_source}\n"
        code_context += f"Stack trace: Most recent frame first:\n {stack_trace}\n"
        code_context += f"Code of class {cls.__name__}:\n {self_source}\n"

        return code_context

    def add_line_numbers(self, code_lines, start=1) -> str:
        source = ""
        for line in code_lines:
            source += f"{start}: {line.strip()}\n"
            start += 1
        return source

    def get_class_source(self, cls, name, full=False):
        if full:
            source = ""
            source_lines, lineno = inspect.getsourcelines(cls)
            source += self.add_line_numbers(source_lines, start=lineno)
            return source

        # full=False, retrieve the source of the class with some code removed
        source = ""
        # Add the class def line and the method implementation to the source
        class_source, lineno = inspect.getsourcelines(cls)
        source += f"{lineno}: {class_source[0]}\n"
        # Add the source of the __init__ method
        if "__init__" in cls.__dict__:
            source_lines, lineno = inspect.getsourcelines(cls.__dict__["__init__"])
            source += self.add_line_numbers(source_lines, start=lineno)

        # Add the source of the method
        if name in cls.__dict__:
            if inspect.isfunction(cls.__dict__[name]):
                source_lines, lineno = inspect.getsourcelines(cls.__dict__[name])
                source += self.add_line_numbers(source_lines, start=lineno)
            else:
                source += f"{name}={cls.__dict__[name]}\n"

        # Add the def line of all the other methods
        for attr_name, attr in cls.__dict__.items():
            if attr_name != "__init__" \
            and attr_name != name:
                if inspect.isfunction(attr):
                    method_source, lineno = inspect.getsourcelines(attr)
                    source += f"{lineno}: {method_source[0]}\n"
                    source += "...\n"
                else:
                    source += f"{lineno}: {attr_name}={attr}\n"
        return source

    def get_parent_class_sources(self, klass, name):
        parent_class_sources = []
        for cls in inspect.getmro(klass):
            # Skip the class itself
            if cls is klass:
                continue
            # Stop when we reach the GenerativeBase class
            if cls.__name__ == "GenerativeBase":
                break
            source = self.get_class_source(cls, name)
            parent_class_sources.append(source)

        # Reverse the list to get the sources in the correct order
        parent_class_sources.reverse()

        return "\n".join(parent_class_sources)

    def get_sibling_class_sources(self, cls, name):
        sibling_class_sources = []
        for parent in cls.__bases__:
            subclasses = parent.__subclasses__()
            for subclass in subclasses:
                if subclass is cls:
                    continue
                source = self.get_class_source(subclass, name)
                sibling_class_sources.append(source)

        return "\n".join(sibling_class_sources)

    def get_calling_code(self, stack=None, stack_depth=0, slice_pre=10, slice_post=10):
        caller_source = ""
        if stack is None:
            caller_frame = inspect.stack()[stack_depth]
        else:
            caller_frame = stack[stack_depth]
        frame_info = inspect.getframeinfo(caller_frame[0])
        # If caller is a method, get the source of the method
        # If caller is module, only get the source immediately around the call
        if frame_info.function != "<module>":
            try:
                caller_source_lines, lineno = inspect.getsourcelines(caller_frame[0])
                caller_source = self.add_line_numbers(caller_source_lines, start=lineno)
            except OSError:
                caller_source = ""
        else:
            try:
                caller_source_lines, lineno = inspect.getsourcelines(caller_frame[0])
                source_we_need = caller_source_lines[frame_info.lineno - slice_pre:frame_info.lineno + slice_post]
                caller_source = self.add_line_numbers(source_we_need, start=frame_info.lineno - slice_pre + 1)
            except OSError:
                caller_source = ""
            except IndexError:
                caller_source = self.get_calling_code(stack=stack, stack_depth=stack_depth, slice_pre=slice_pre - 1, slice_post=slice_post - 1)

        return caller_source

    def get_stack_trace(self, frozen_stack, start_depth=1):
        stack_trace = ""
        for frame in frozen_stack[start_depth:]:
            frame_info = inspect.getframeinfo(frame[0])
            stack_trace += f"File: {frame_info.filename}, Line: {frame_info.lineno}, Function: {frame_info.function}\n"
        return stack_trace

    def prompt_ai(self, prompt):
        try:
            print("AI prompt:", prompt, "\n")
            # Escape the prompt to avoid special characters
            prompt = prompt.replace('"', '\\"')
            response = subprocess.run(["tgpt", "-q", "--provider", "pollinations", prompt], stdout=subprocess.PIPE, check=True, text=True).stdout.strip()
            print("AI response:", response, "\n")
            return response
        except subprocess.CalledProcessError as e:
            raise CodeGenerationException(f"Error generating code: {e}")



